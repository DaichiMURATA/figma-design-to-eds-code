# EDS Block Generation Rules - Complete Automated Workflow

## ðŸŽ¯ Core Principles

1. **Figma Fidelity**: 100% accurate reproduction of Figma designs
2. **1:1 Variant Mapping**: Every Figma Variant = One Storybook Story
3. **Design Token Usage**: All styles use CSS Custom Properties (no hardcoded values)
4. **Automation**: Minimize manual intervention
5. **Reproducibility**: Same input â†’ Same output

---

## ðŸ“‹ Block Generation Workflow

### Phase 1: Figma Analysis & Style Extraction

#### Step 1.1: Identify Component Structure
```bash
# When user provides: @figma <url> or --node-id=<id>
npm run inspect-figma -- --node-id=<component-set-node-id>
```

**Extract**:
- Component Set structure
- All Variant Node IDs
- Variant names and properties
- Component dimensions (width Ã— height)

**Update**: `config/figma/figma-urls.json` with Variant mapping

#### Step 1.2: Extract Detailed Styles from Each Variant

**For each Variant Node ID**, fetch and extract:

```javascript
// Figma API call
GET /v1/files/{fileId}/nodes?ids={nodeId}

// Extract from response:
{
  // Layout (Auto Layout)
  layoutMode: "HORIZONTAL" | "VERTICAL" | "NONE",
  primaryAxisAlignItems: "MIN" | "CENTER" | "MAX" | "SPACE_BETWEEN",
  counterAxisAlignItems: "MIN" | "CENTER" | "MAX",
  itemSpacing: number,
  paddingTop: number,
  paddingRight: number,
  paddingBottom: number,
  paddingLeft: number,
  
  // Visual Properties
  fills: [{ type, color: { r, g, b, a }, opacity }],
  strokes: [{ type, color: { r, g, b, a }, strokeWeight }],
  cornerRadius: number | { topLeft, topRight, bottomLeft, bottomRight },
  opacity: number,
  
  // Effects
  effects: [
    { type: "DROP_SHADOW", radius, offset: { x, y }, color, spread }
  ],
  
  // Typography (for TEXT nodes)
  style: {
    fontFamily: string,
    fontSize: number,
    fontWeight: number,
    lineHeightPx: number,
    letterSpacing: number,
    textAlignHorizontal: "LEFT" | "CENTER" | "RIGHT",
    textAlignVertical: "TOP" | "CENTER" | "BOTTOM"
  }
}
```

**Save to**: `blocks/{block}/figma-styles.json`

#### Step 1.3: Map Figma Values to Design Tokens

**Process**:
1. Load global design tokens from `styles/styles.css`
2. For each extracted style value:
   - Search for matching token
   - If found: use `var(--token-name)`
   - If not found: use literal value + add TODO comment

**Example**:
```javascript
// Extracted: paddingTop: 40
// Global tokens: --spacing-xl: 40px
// Result: padding-top: var(--spacing-xl);

// Extracted: cornerRadius: 5
// Global tokens: (no match)
// Result: border-radius: 5px; /* TODO: Create design token */
```

**Save to**: `blocks/{block}/token-mapping.json`

#### Step 1.4: Download All Assets

```bash
npm run download-all-variants -- --block=<block-name>
```

**Downloads**:
- All images from all Variants
- Saves to `blocks/{block}/assets/`
- Creates `metadata.json` for each Variant

---

### Phase 2: Code Generation

#### Step 2.1: Generate CSS

**Template Structure**:
```css
/**
 * {Block} Block Styles
 * Generated from Figma Component: {nodeId}
 */

/* Root Block - from Figma Component Set root */
.{block} {
  /* Layout - from Figma Auto Layout */
  display: {layoutMode === "HORIZONTAL" ? "flex" : "block"};
  flex-direction: {layoutMode === "HORIZONTAL" ? "row" : "column"};
  justify-content: {mapAlignment(primaryAxisAlignItems)};
  align-items: {mapAlignment(counterAxisAlignItems)};
  gap: var({mapToken(itemSpacing)});
  
  /* Spacing - mapped to design tokens */
  padding: var({mapToken(paddingTop)}) var({mapToken(paddingRight)}) 
           var({mapToken(paddingBottom)}) var({mapToken(paddingLeft)});
  margin: 0 auto;
  
  /* Sizing - from absoluteBoundingBox */
  max-width: var(--container-max-width, {width}px);
  width: 100%;
  
  /* Visual - from fills/strokes */
  background-color: {mapColor(fills[0])};
  border: {strokes[0] ? mapStroke(strokes[0]) : "none"};
  border-radius: var({mapToken(cornerRadius)});
  opacity: {opacity};
  
  /* Effects - from effects array */
  box-shadow: {mapShadow(effects)};
  
  /* Position */
  position: relative;
}

/* Child Elements - from Figma node hierarchy */
{for each child node:}
.{block} .{block}-{childNodeName} {
  {recursively apply same logic}
}
```

**Automation Function**:
```javascript
function generateCSSFromFigmaNode(node, selector, tokenMappings) {
  const properties = [];
  
  // Layout
  if (node.layoutMode) {
    properties.push(...convertAutoLayoutToCSS(node));
  }
  
  // Spacing
  if (node.paddingTop || node.paddingLeft) {
    const token = findTokenForValue(node.paddingTop, tokenMappings);
    properties.push(`padding: var(${token}, ${node.paddingTop}px);`);
  }
  
  // Visual
  if (node.fills) {
    const color = convertColor(node.fills[0]);
    const token = findTokenForColor(color, tokenMappings);
    properties.push(`background-color: var(${token}, ${color});`);
  }
  
  // ... etc for all properties
  
  return { selector, properties };
}
```

#### Step 2.2: Generate JavaScript

**Follow EDS Block Collection patterns**:

```javascript
/**
 * {Block} Block
 * Generated from Figma Component: {nodeId}
 * 
 * Variants: {list variant names}
 */

export default function decorate(block) {
  // 1. Extract EDS-generated structure
  const rows = [...block.children];
  
  // 2. Create semantic HTML structure
  // Based on Figma hierarchy
  const container = document.createElement('div');
  container.className = `${block.className.split(' ')[0]}-container`;
  
  rows.forEach((row, index) => {
    const cols = [...row.children];
    // Process based on Figma variant structure
    processRow(cols, container, index);
  });
  
  // 3. Add interactivity (if needed)
  if (hasInteractiveElements(container)) {
    setupEventHandlers(container);
  }
  
  // 4. Add accessibility attributes
  enhanceAccessibility(container);
  
  // 5. Replace block content
  block.textContent = '';
  block.append(container);
}
```

#### Step 2.3: Generate Storybook Stories

**1:1 Figma Variant â†’ Story mapping**:

```javascript
/**
 * {Block} Block Stories
 * Auto-generated from Figma Variants
 * 
 * Figma Component Set: {componentSetNodeId}
 */

import '../../styles/styles.css';
import './{block}.css';
import decorate from './{block}.js';

// Import assets (auto-generated from download-all-variants)
{for each variant with images:}
import {variantName}Image from './assets/{variantName}-image.png';

export default {
  title: 'Blocks/{Block}',
  tags: ['autodocs'],
  parameters: {
    layout: 'fullscreen',
    chromatic: {
      viewports: [375, 1200],
      delay: 500,
    },
  },
};

// Helper to create block HTML
const createBlockHTML = (config) => {
  const block = document.createElement('div');
  block.className = '{block} block';
  block.setAttribute('data-block-name', '{block}');
  
  // Build structure based on config
  // ...
  
  decorate(block);
  return block;
};

// Generate Stories from Figma Variants
{for each variant in config/figma/figma-urls.json:}
/**
 * Variant: {variantName}
 * Figma Node: {variantNodeId}
 * Properties: {variantProperties}
 */
export const {variantName} = {
  render: () => {
    return createBlockHTML({
      images: [{variantName}Image],
      // ... other config from Figma
    });
  },
  parameters: {
    design: {
      type: 'figma',
      url: 'https://www.figma.com/file/{fileId}?node-id={variantNodeId}',
    },
  },
};
```

---

### Phase 3: Automated Visual Validation

#### Step 3.1: Run Visual Validation for Each Variant

```bash
# For each variant in config
for variantNodeId in $(get-variant-node-ids {block}); do
  npm run validate-block -- \
    --block={block} \
    --node-id=$variantNodeId \
    --demo
done
```

**Validation Process**:
1. Fetch Figma screenshot (scale=2, Retina)
2. Get component size from Figma API
3. Set Storybook viewport to match Figma size
4. Capture Storybook screenshot (deviceScaleFactor=2)
5. Compare pixel-by-pixel (pixelmatch)
6. If diff > threshold (0.1%):
   - Re-fetch Figma styles
   - Apply CSS fixes
   - Wait for hot reload
   - Repeat (max 5 iterations)

#### Step 3.2: CSS Auto-Fix Logic

**Current**: Heuristic-based fixes
**Next**: Figma API-driven fixes

```javascript
async function applyIntelligentFixes(blockName, figmaNodeId, diffPercentage) {
  // 1. Re-fetch current Figma styles
  const figmaStyles = await fetchFigmaNodeStyles(figmaNodeId);
  
  // 2. Re-fetch current CSS
  const currentCSS = readFileSync(`blocks/${blockName}/${blockName}.css`, 'utf-8');
  
  // 3. Compare and identify missing/incorrect properties
  const mismatches = compareStylesWithCSS(figmaStyles, currentCSS);
  
  // 4. Apply fixes
  const fixes = mismatches.map(mismatch => ({
    selector: mismatch.selector,
    property: mismatch.property,
    currentValue: mismatch.cssValue,
    expectedValue: mismatch.figmaValue,
    token: findTokenForValue(mismatch.figmaValue)
  }));
  
  // 5. Update CSS
  let updatedCSS = currentCSS;
  for (const fix of fixes) {
    updatedCSS = applyCSSFix(updatedCSS, fix);
  }
  
  writeFileSync(`blocks/${blockName}/${blockName}.css`, updatedCSS);
  
  return fixes;
}
```

---

### Phase 4: Documentation & Integration

#### Step 4.1: Auto-Generate Documentation

```markdown
# {Block} Block

## Figma Design
- **Component Set**: [{nodeId}](figma-url)
- **File**: {fileName}
- **Last Updated**: {timestamp}

## Variants ({variantCount})

{for each variant:}
### {VariantName}
- **Node ID**: {variantNodeId}
- **Dimensions**: {width} Ã— {height}
- **Properties**: {variantProperties}
- **Preview**: ![Storybook]({storybookUrl})

## Design Tokens Used
{for each token in token-mapping.json:}
- `{tokenName}`: {value}

## Usage
\`\`\`html
<!-- In DarkAlley Document -->
| {Block} |
| --- |
| Content |
\`\`\`

## Accessibility
- âœ… Keyboard navigation
- âœ… Screen reader support
- âœ… ARIA attributes
- âœ… Focus management

## Chromatic
- **Status**: {chromaticStatus}
- **Last Baseline**: {lastBaseline}
- **Storybook Build**: [View]({chromaticUrl})
```

#### Step 4.2: Update Config

```json
// config/figma/figma-urls.json
{
  "components": {
    "{block}": {
      "nodeId": "{componentSetNodeId}",
      "variants": {
        "{variantName1}": "{variantNodeId1}",
        "{variantName2}": "{variantNodeId2}"
      },
      "status": "validated",
      "lastGenerated": "{timestamp}",
      "lastValidated": "{timestamp}",
      "visualDiff": {
        "{variantName1}": "2.3%",
        "{variantName2}": "1.8%"
      }
    }
  }
}
```

---

## ðŸ¤– Automation Commands

### Full End-to-End Generation
```bash
npm run generate-block -- --figma-node=<component-set-id> --block=<name>
```

**Executes**:
1. `inspect-figma`
2. `extract-styles`
3. `map-tokens`
4. `download-all-variants`
5. `generate-css`
6. `generate-js`
7. `generate-stories`
8. `validate-all-variants`
9. `generate-docs`

### Individual Commands (for debugging/iteration)
```bash
# Analysis
npm run inspect-figma -- --node-id=<id>
npm run extract-styles -- --node-id=<id> --block=<name>
npm run map-tokens -- --block=<name>

# Assets
npm run download-assets -- --node-id=<id> --block=<name>
npm run download-all-variants -- --block=<name>

# Code Generation (to be implemented)
npm run generate-css -- --block=<name>
npm run generate-js -- --block=<name>
npm run generate-stories -- --block=<name>

# Validation
npm run validate-block -- --block=<name> --node-id=<id>
npm run validate-all-variants -- --block=<name>

# Documentation (to be implemented)
npm run generate-docs -- --block=<name>
```

---

## âœ… Success Criteria

### Per Block
- [ ] All Figma Variants have corresponding Stories (1:1 mapping)
- [ ] Visual diff < 5% for all Variants
- [ ] 90%+ of styles use design tokens (not hardcoded)
- [ ] HTML structure matches EDS specification
- [ ] All assets downloaded and referenced
- [ ] Chromatic baseline established
- [ ] Documentation complete

### Per Variant
- [ ] Figma Node ID documented
- [ ] Dimensions match exactly (width, height)
- [ ] Layout properties match (flex, gap, alignment)
- [ ] Spacing properties match (padding, margin)
- [ ] Visual properties match (colors, borders, shadows)
- [ ] Typography properties match (font, size, weight)
- [ ] Interactive states work (hover, focus, active)
- [ ] Responsive behavior correct

---

## ðŸ“ File Structure (Auto-Generated)

```
blocks/{block}/
â”œâ”€â”€ {block}.js                      # Block logic
â”œâ”€â”€ {block}.css                     # Block styles (token-based)
â”œâ”€â”€ {block}.stories.js              # Storybook stories (all variants)
â”œâ”€â”€ {block}.md                      # Documentation
â”œâ”€â”€ figma-styles.json               # Extracted Figma styles
â”œâ”€â”€ token-mapping.json              # Figma value â†’ CSS token mapping
â””â”€â”€ assets/
    â”œâ”€â”€ metadata.json               # Asset registry
    â”œâ”€â”€ {variant1}-image-1.png      # Downloaded images
    â”œâ”€â”€ {variant1}-image-2.png
    â”œâ”€â”€ {variant2}-image-1.png
    â””â”€â”€ ...
```

---

## ðŸ”„ Regeneration & Updates

When Figma design changes:

1. **Detect Change**: Webhook or manual trigger
2. **Re-extract**: `npm run extract-styles -- --node-id=<id> --block=<name>`
3. **Compare**: Diff old vs new `figma-styles.json`
4. **Re-generate**: `npm run generate-css -- --block=<name>`
5. **Re-validate**: `npm run validate-all-variants -- --block=<name>`
6. **Create PR**: Review and approve changes
7. **Update Baseline**: Merge to main

---

## ðŸŽ¯ Current Implementation Status

### âœ… Implemented
- Figma Node Inspector
- Figma Assets Downloader
- Automated Visual Validation (pixel-by-pixel)
- Storybook Screenshot Capture
- Variant â†’ Story mapping

### ðŸš§ In Progress
- Figma Styles Extraction (detailed)
- Design Token Mapping
- CSS Auto-Generation
- JS Auto-Generation
- Stories Auto-Generation

### ðŸ“‹ Planned
- Vision LLM Integration
- Element-Level Validation
- Full End-to-End Command
- Documentation Auto-Generation
- Figma Webhook Integration

---

## ðŸ“– Reference Documents

- **Complete Workflow**: `docs/BLOCK-GENERATION-COMPLETE-WORKFLOW.md`
- **Visual Validation**: `docs/FIGMA-STORYBOOK-AUTO-VALIDATION-COMPLETE.md`
- **Chromatic Strategy**: `ROADMAP.md`
- **Quick Start**: `QUICKSTART.md`
